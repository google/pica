// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! ## Specifications
//! - [MAC] FiRa Consortium UWB MAC Technical Requirements
//! - [UCI] FiRa Consortium UWB Command Interface Generic Technical specification

use crate::packets::uci::{self, *};
use crate::{AppConfig, MacAddress, PicaCommand};
use bytes::BytesMut;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tokio::time;

use super::UciPacket;

pub const MAX_SESSION: usize = 255;
/// cf. [UCI] 8.3 Table 29
pub const MAX_NUMBER_OF_CONTROLEES: usize = 8;

enum SubSessionKey {
    None,
    Short([u8; 16]),
    Extended([u8; 32]),
}

struct Controlee {
    short_address: MacAddress,
    sub_session_id: u32,
    #[allow(dead_code)]
    session_key: SubSessionKey,
}

impl From<&uci::Controlee> for Controlee {
    fn from(value: &uci::Controlee) -> Self {
        Controlee {
            short_address: MacAddress::Short(value.short_address),
            sub_session_id: value.subsession_id,
            session_key: SubSessionKey::None,
        }
    }
}

impl From<&uci::Controlee_V2_0_16_Byte_Version> for Controlee {
    fn from(value: &uci::Controlee_V2_0_16_Byte_Version) -> Self {
        Controlee {
            short_address: MacAddress::Short(value.short_address),
            sub_session_id: value.subsession_id,
            session_key: SubSessionKey::Short(value.subsession_key),
        }
    }
}

impl From<&uci::Controlee_V2_0_32_Byte_Version> for Controlee {
    fn from(value: &uci::Controlee_V2_0_32_Byte_Version) -> Self {
        Controlee {
            short_address: MacAddress::Short(value.short_address),
            sub_session_id: value.subsession_id,
            session_key: SubSessionKey::Extended(value.subsession_key),
        }
    }
}

pub struct Session {
    /// cf. [UCI] 7.1
    pub state: SessionState,
    /// cf. [UCI] 7.2 Table 13: 4 octets unique random number generated by application
    id: u32,
    device_handle: usize,
    data: BytesMut,

    session_type: SessionType,
    pub sequence_number: u32,
    pub app_config: AppConfig,
    ranging_task: Option<JoinHandle<()>>,
    tx: mpsc::UnboundedSender<UciPacket>,
    pica_tx: mpsc::Sender<PicaCommand>,
}

impl Session {
    pub fn new(
        id: u32,
        session_type: SessionType,
        device_handle: usize,
        tx: mpsc::UnboundedSender<UciPacket>,
        pica_tx: mpsc::Sender<PicaCommand>,
    ) -> Self {
        Self {
            state: SessionState::SessionStateDeinit,
            id,
            device_handle,
            data: BytesMut::new(),
            session_type,
            sequence_number: 0,
            app_config: AppConfig::default(),
            ranging_task: None,
            tx,
            pica_tx,
        }
    }

    pub fn set_state(&mut self, session_state: SessionState, reason_code: ReasonCode) {
        // No transition: ignore
        if session_state == self.state {
            return;
        }

        // Send status notification
        self.state = session_state;
        let tx = self.tx.clone();
        let session_id = self.id;
        tokio::spawn(async move {
            time::sleep(Duration::from_millis(1)).await;
            tx.send(
                SessionStatusNtfBuilder {
                    session_token: session_id,
                    session_state,
                    reason_code: reason_code.into(),
                }
                .build()
                .into(),
            )
            .unwrap()
        });
    }

    pub fn get_dst_mac_address(&self) -> &[MacAddress] {
        &self.app_config.dst_mac_address
    }

    pub fn is_session_info_ntf_enabled(&self) -> bool {
        self.app_config.session_info_ntf_config != uci::SessionInfoNtfConfig::Disable
    }

    #[allow(unused)]
    pub fn is_session_data_transfer_status_ntf_enabled(&self) -> bool {
        self.app_config.session_data_transfer_status_ntf_config
            != uci::SessionDataTransferStatusNtfConfig::Disable
    }

    pub fn data(&self) -> &BytesMut {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear()
    }

    pub fn session_type(&self) -> SessionType {
        self.session_type
    }

    pub fn session_state(&self) -> SessionState {
        self.state
    }

    pub fn init(&mut self) {
        self.set_state(
            SessionState::SessionStateInit,
            ReasonCode::StateChangeWithSessionManagementCommands,
        );
    }

    fn command_set_app_config(&mut self, cmd: SessionSetAppConfigCmd) -> SessionSetAppConfigRsp {
        // TODO properly handle these asserts
        log::debug!(
            "[{}:0x{:x}] Session Set App Config",
            self.device_handle,
            self.id
        );
        assert_eq!(self.id, cmd.get_session_token());
        assert!(
            self.session_type.eq(&SessionType::FiraRangingSession)
                || self
                    .session_type
                    .eq(&SessionType::FiraRangingAndInBandDataSession)
        );

        if self.state == SessionState::SessionStateActive {
            const IMMUTABLE_PARAMETERS: &[AppConfigTlvType] = &[AppConfigTlvType::AoaResultReq];
            if cmd
                .get_tlvs()
                .iter()
                .any(|cfg| IMMUTABLE_PARAMETERS.contains(&cfg.cfg_id))
            {
                return SessionSetAppConfigRspBuilder {
                    status: StatusCode::UciStatusSessionActive,
                    cfg_status: vec![],
                }
                .build();
            }
        }

        let (status, invalid_parameters) = if self.state != SessionState::SessionStateInit
            && self.state != SessionState::SessionStateActive
        {
            (StatusCode::UciStatusRejected, Vec::new())
        } else {
            let mut app_config = self.app_config.clone();
            let mut invalid_parameters = vec![];
            for cfg in cmd.get_tlvs() {
                match app_config.set(cfg.cfg_id, &cfg.v) {
                    Ok(_) => (),
                    Err(_) => invalid_parameters.push(AppConfigStatus {
                        cfg_id: cfg.cfg_id,
                        status: uci::StatusCode::UciStatusInvalidParam,
                    }),
                }
            }

            // [UCI] 7.5.1 Configuration of a Session
            // This section defines the mandatory APP Configuration Parameters to be applied
            // by the Host for FiRa defined UWB Session types. The Host shall apply these
            // mandatory configurations to move the Session State from SESSION_STATE_INIT
            // to SESSION_STATE_IDLE.
            //
            // - DEVICE_ROLE
            // - MULTI_NODE_MODE
            // - RANGING_ROUND_USAGE
            // - DEVICE_MAC_ADDRESS
            // - DEVICE_TYPE (see Note1)
            // - SCHEDULE_MODE
            if app_config.device_role.is_none()
                || app_config.multi_node_mode.is_none()
                || app_config.ranging_round_usage.is_none()
                || app_config.device_mac_address.is_none()
                || app_config.schedule_mode.is_none()
            {
                log::error!(
                    "[{}:0x{:x}] missing mandatory APP config parameters",
                    self.device_handle,
                    self.id
                );
                return SessionSetAppConfigRspBuilder {
                    status: uci::StatusCode::UciStatusRejected,
                    cfg_status: vec![],
                }
                .build();
            }

            if invalid_parameters.is_empty() {
                self.app_config = app_config;
                if self.state == SessionState::SessionStateInit {
                    self.set_state(
                        SessionState::SessionStateIdle,
                        ReasonCode::StateChangeWithSessionManagementCommands,
                    );
                }
                (StatusCode::UciStatusOk, invalid_parameters)
            } else {
                (StatusCode::UciStatusInvalidParam, invalid_parameters)
            }
        };

        SessionSetAppConfigRspBuilder {
            status,
            cfg_status: invalid_parameters,
        }
        .build()
    }

    fn command_get_app_config(&self, cmd: SessionGetAppConfigCmd) -> SessionGetAppConfigRsp {
        log::debug!(
            "[{}:0x{:x}] Session Get App Config",
            self.device_handle,
            self.id
        );
        assert_eq!(self.id, cmd.get_session_token());

        let (status, valid_parameters) = {
            let mut valid_parameters = vec![];
            let mut invalid_parameters = vec![];
            for id in cmd.get_app_cfg() {
                match self.app_config.get(*id) {
                    Ok(value) => valid_parameters.push(AppConfigTlv {
                        cfg_id: *id,
                        v: value,
                    }),
                    Err(_) => invalid_parameters.push(AppConfigTlv {
                        cfg_id: *id,
                        v: vec![],
                    }),
                }
            }

            if invalid_parameters.is_empty() {
                (StatusCode::UciStatusOk, valid_parameters)
            } else {
                (StatusCode::UciStatusFailed, Vec::new())
            }
        };
        SessionGetAppConfigRspBuilder {
            status,
            tlvs: valid_parameters,
        }
        .build()
    }

    fn command_get_state(&self, cmd: SessionGetStateCmd) -> SessionGetStateRsp {
        log::debug!("[{}:0x{:x}] Session Get State", self.device_handle, self.id);
        assert_eq!(self.id, cmd.get_session_token());
        SessionGetStateRspBuilder {
            status: StatusCode::UciStatusOk,
            session_state: self.state,
        }
        .build()
    }

    fn command_update_controller_multicast_list(
        &mut self,
        cmd: SessionUpdateControllerMulticastListCmd,
    ) -> SessionUpdateControllerMulticastListRsp {
        log::debug!(
            "[{}:0x{:x}] Session Update Controller Multicast List",
            self.device_handle,
            self.id
        );
        assert_eq!(self.id, cmd.get_session_token());
        if (self.state != SessionState::SessionStateActive
            && self.state != SessionState::SessionStateIdle)
            || self.app_config.device_type != Some(DeviceType::Controller)
            || self.app_config.multi_node_mode != Some(MultiNodeMode::OneToMany)
        {
            return SessionUpdateControllerMulticastListRspBuilder {
                status: StatusCode::UciStatusRejected,
            }
            .build();
        }
        let action = cmd.get_action();
        let mut dst_addresses = self.app_config.dst_mac_address.clone();
        let new_controlees: Vec<Controlee> = match action {
            UpdateMulticastListAction::AddControlee
            | UpdateMulticastListAction::RemoveControlee => {
                if let Ok(packet) =
                    SessionUpdateControllerMulticastListCmdPayload::parse(cmd.get_payload())
                {
                    packet
                        .controlees
                        .iter()
                        .map(|controlee| controlee.into())
                        .collect()
                } else {
                    return SessionUpdateControllerMulticastListRspBuilder {
                        status: StatusCode::UciStatusSyntaxError,
                    }
                    .build();
                }
            }
            UpdateMulticastListAction::AddControleeWithShortSubSessionKey => {
                if let Ok(packet) =
                    SessionUpdateControllerMulticastListCmd_2_0_16_Byte_Payload::parse(
                        cmd.get_payload(),
                    )
                {
                    packet
                        .controlees
                        .iter()
                        .map(|controlee| controlee.into())
                        .collect()
                } else {
                    return SessionUpdateControllerMulticastListRspBuilder {
                        status: StatusCode::UciStatusSyntaxError,
                    }
                    .build();
                }
            }
            UpdateMulticastListAction::AddControleeWithExtendedSubSessionKey => {
                if let Ok(packet) =
                    SessionUpdateControllerMulticastListCmd_2_0_32_Byte_Payload::parse(
                        cmd.get_payload(),
                    )
                {
                    packet
                        .controlees
                        .iter()
                        .map(|controlee| controlee.into())
                        .collect()
                } else {
                    return SessionUpdateControllerMulticastListRspBuilder {
                        status: StatusCode::UciStatusSyntaxError,
                    }
                    .build();
                }
            }
        };
        let mut controlee_status = Vec::new();

        let session_id = self.id;
        let mut status = StatusCode::UciStatusOk;

        match action {
            UpdateMulticastListAction::AddControlee
            | UpdateMulticastListAction::AddControleeWithShortSubSessionKey
            | UpdateMulticastListAction::AddControleeWithExtendedSubSessionKey => {
                new_controlees.iter().for_each(|controlee| {
                    let mut update_status = MulticastUpdateStatusCode::StatusOkMulticastListUpdate;
                    if !dst_addresses.contains(&controlee.short_address) {
                        if dst_addresses.len() == MAX_NUMBER_OF_CONTROLEES {
                            status = StatusCode::UciStatusMulticastListFull;
                            update_status = MulticastUpdateStatusCode::StatusErrorMulticastListFull;
                        } else if (action
                            == UpdateMulticastListAction::AddControleeWithShortSubSessionKey
                            || action
                                == UpdateMulticastListAction::AddControleeWithExtendedSubSessionKey)
                            && self.app_config.sts_config
                                != uci::StsConfig::ProvisionedForResponderSubSessionKey
                        {
                            // If Action is 0x02 or 0x03 for STS_CONFIG values other than
                            // 0x04, the UWBS shall return SESSION_UPDATE_CONTROLLER_MULTICAST_LIST_NTF
                            // with Status set to STATUS_ERROR_SUB_SESSION_KEY_NOT_APPLICABLE for each
                            // Controlee in the Controlee List.
                            status = StatusCode::UciStatusFailed;
                            update_status =
                                MulticastUpdateStatusCode::StatusErrorSubSessionKeyNotApplicable;
                        } else {
                            dst_addresses.push(controlee.short_address);
                        };
                    }
                    controlee_status.push(ControleeStatus {
                        mac_address: match controlee.short_address {
                            MacAddress::Short(address) => address,
                            MacAddress::Extended(_) => panic!("Extended address is not supported!"),
                        },
                        subsession_id: controlee.sub_session_id,
                        status: update_status,
                    });
                });
            }
            UpdateMulticastListAction::RemoveControlee => {
                new_controlees.iter().for_each(|controlee: &Controlee| {
                    let pica_tx = self.pica_tx.clone();
                    let address = controlee.short_address;
                    let attempt_count = self.app_config.in_band_termination_attempt_count;
                    let mut update_status = MulticastUpdateStatusCode::StatusOkMulticastListUpdate;
                    if !dst_addresses.contains(&address) {
                        status = StatusCode::UciStatusAddressNotFound;
                        update_status = MulticastUpdateStatusCode::StatusErrorKeyFetchFail;
                    } else {
                        dst_addresses.retain(|value| *value != address);
                        // If IN_BAND_TERMINATION_ATTEMPT_COUNT is not equal to 0x00, then the
                        // UWBS shall transmit the RCM with the “Stop Ranging” bit set to ‘1’
                        // for IN_BAND_TERMINATION_ATTEMPT_COUNT times to the corresponding
                        // Controlee.
                        if attempt_count != 0 {
                            tokio::spawn(async move {
                                for _ in 0..attempt_count {
                                    pica_tx
                                        .send(PicaCommand::StopRanging(address, session_id))
                                        .await
                                        .unwrap()
                                }
                            });
                        }
                    }
                    controlee_status.push(ControleeStatus {
                        mac_address: match address {
                            MacAddress::Short(addr) => addr,
                            MacAddress::Extended(_) => panic!("Extended address is not supported!"),
                        },
                        subsession_id: controlee.sub_session_id,
                        status: update_status,
                    });
                });
            }
        }
        self.app_config.number_of_controlees = dst_addresses.len() as u8;
        self.app_config.dst_mac_address = dst_addresses.clone();
        // If the multicast list becomes empty, the UWBS shall move the session to
        // SESSION_STATE_IDLE by sending the SESSION_STATUS_NTF with Reason Code
        // set to ERROR_INVALID_NUM_OF_CONTROLEES.
        if self.app_config.dst_mac_address.is_empty() {
            self.set_state(
                SessionState::SessionStateIdle,
                ReasonCode::ErrorInvalidNumOfControlees,
            )
        }
        let tx = self.tx.clone();
        tokio::spawn(async move {
            tx.send(
                SessionUpdateControllerMulticastListNtfBuilder {
                    controlee_status,
                    remaining_multicast_list_size: dst_addresses.len() as u8,
                    session_token: session_id,
                }
                .build()
                .into(),
            )
            .unwrap()
        });
        SessionUpdateControllerMulticastListRspBuilder { status }.build()
    }

    fn command_range_start(&mut self, cmd: SessionStartCmd) -> SessionStartRsp {
        log::debug!("[{}:0x{:x}] Range Start", self.device_handle, self.id);
        assert_eq!(self.id, cmd.get_session_id());

        let status = if self.state != SessionState::SessionStateIdle {
            StatusCode::UciStatusSessionNotConfigured
        } else {
            assert!(self.ranging_task.is_none());
            assert_eq!(self.state, SessionState::SessionStateIdle);

            let session_id = self.id;
            let ranging_interval =
                time::Duration::from_millis(self.app_config.ranging_duration as u64);
            let device_handle = self.device_handle;
            let tx = self.pica_tx.clone();
            self.ranging_task = Some(tokio::spawn(async move {
                loop {
                    time::sleep(ranging_interval).await;
                    tx.send(PicaCommand::Ranging(device_handle, session_id))
                        .await
                        .unwrap();
                }
            }));
            self.set_state(
                SessionState::SessionStateActive,
                ReasonCode::StateChangeWithSessionManagementCommands,
            );
            StatusCode::UciStatusOk
        };
        SessionStartRspBuilder { status }.build()
    }

    pub fn stop_ranging_task(&mut self) {
        if let Some(handle) = &self.ranging_task {
            handle.abort();
            self.ranging_task = None;
        }
    }
    fn command_range_stop(&mut self, cmd: SessionStopCmd) -> SessionStopRsp {
        log::debug!("[{}:0x{:x}] Range Stop", self.device_handle, self.id);
        assert_eq!(self.id, cmd.get_session_id());

        let status = if self.state != SessionState::SessionStateActive {
            StatusCode::UciStatusSessionActive
        } else {
            self.stop_ranging_task();
            self.set_state(
                SessionState::SessionStateIdle,
                ReasonCode::StateChangeWithSessionManagementCommands,
            );
            StatusCode::UciStatusOk
        };
        SessionStopRspBuilder { status }.build()
    }

    fn command_get_ranging_count(
        &self,
        cmd: SessionGetRangingCountCmd,
    ) -> SessionGetRangingCountRsp {
        log::debug!(
            "[{}:0x{:x}] Range Get Ranging Count",
            self.device_handle,
            self.id
        );
        assert_eq!(self.id, cmd.get_session_id());

        SessionGetRangingCountRspBuilder {
            status: StatusCode::UciStatusOk,
            count: self.sequence_number,
        }
        .build()
    }

    pub fn session_command(&mut self, cmd: SessionConfigCommand) -> SessionConfigResponse {
        match cmd.specialize() {
            SessionConfigCommandChild::SessionSetAppConfigCmd(cmd) => {
                self.command_set_app_config(cmd).into()
            }
            SessionConfigCommandChild::SessionGetAppConfigCmd(cmd) => {
                self.command_get_app_config(cmd).into()
            }
            SessionConfigCommandChild::SessionGetStateCmd(cmd) => {
                self.command_get_state(cmd).into()
            }
            SessionConfigCommandChild::SessionUpdateControllerMulticastListCmd(cmd) => {
                self.command_update_controller_multicast_list(cmd).into()
            }
            _ => panic!("Unsupported session command"),
        }
    }

    pub fn ranging_command(&mut self, cmd: SessionControlCommand) -> SessionControlResponse {
        match cmd.specialize() {
            SessionControlCommandChild::SessionStartCmd(cmd) => {
                self.command_range_start(cmd).into()
            }
            SessionControlCommandChild::SessionStopCmd(cmd) => self.command_range_stop(cmd).into(),
            SessionControlCommandChild::SessionGetRangingCountCmd(cmd) => {
                self.command_get_ranging_count(cmd).into()
            }
            _ => panic!("Unsupported ranging command"),
        }
    }

    pub fn data_message_snd(&mut self, data: DataMessageSnd) -> SessionControlNotification {
        log::debug!("[{}] data_message_snd", self.device_handle);
        let session_token = data.get_session_handle();
        let uci_sequence_number = data.get_data_sequence_number() as u8;

        if self.session_type != SessionType::FiraRangingAndInBandDataSession {
            return DataTransferStatusNtfBuilder {
                session_token,
                status: DataTransferNtfStatusCode::UciDataTransferStatusSessionTypeNotSupported,
                tx_count: 1, // TODO: support for retries?
                uci_sequence_number,
            }
            .build()
            .into();
        }

        assert_eq!(self.id, session_token);

        self.data.extend_from_slice(data.get_application_data());

        DataCreditNtfBuilder {
            credit_availability: CreditAvailability::CreditAvailable,
            session_token,
        }
        .build()
        .into()
    }
}

impl Drop for Session {
    fn drop(&mut self) {
        // Make sure to abort the ranging task when dropping the session,
        // the default behaviour when dropping a task handle is to detach
        // the task, which is undesirable.
        self.stop_ranging_task();
        self.set_state(
            SessionState::SessionStateDeinit,
            ReasonCode::StateChangeWithSessionManagementCommands,
        );
    }
}
